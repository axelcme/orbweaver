<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Living Presence - Orbs and Elementals</title>
    <style>
      body {
        margin: 0;
        padding: 40px;
        min-height: 100vh;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, sans-serif;
        overflow-x: hidden;
        position: relative;
      }

      /* Sample content to show orbs floating over */
      .content {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        position: relative;
        z-index: 1;
      }

      h1 {
        color: #2d3748;
        margin-bottom: 20px;
      }

      p {
        color: #4a5568;
        line-height: 1.6;
      }

      /* Canvas for the living presences */
      #presence-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
      }

      /* Butterfly element */
      .butterfly {
        position: fixed;
        width: 30px;
        height: 20px;
        pointer-events: none;
        z-index: 11;
        opacity: 0;
        transition: opacity 2s ease;
      }

      .butterfly-wing {
        position: absolute;
        width: 15px;
        height: 20px;
        background: radial-gradient(
          ellipse at center,
          rgba(255, 179, 71, 0.3) 0%,
          rgba(255, 206, 84, 0.2) 40%,
          rgba(255, 255, 255, 0.1) 100%
        );
        border-radius: 50% 10% 50% 10%;
      }

      .butterfly-wing.left {
        left: 0;
        transform-origin: right center;
        animation: flutter-left 0.2s infinite alternate ease-in-out;
      }

      .butterfly-wing.right {
        right: 0;
        transform-origin: left center;
        animation: flutter-right 0.2s infinite alternate ease-in-out;
        transform: scaleX(-1);
      }

      @keyframes flutter-left {
        0% {
          transform: rotateY(0deg);
        }
        100% {
          transform: rotateY(50deg);
        }
      }

      @keyframes flutter-right {
        0% {
          transform: scaleX(-1) rotateY(0deg);
        }
        100% {
          transform: scaleX(-1) rotateY(50deg);
        }
      }

      /* Glimmer effect for special moments */
      .glimmer {
        position: fixed;
        width: 4px;
        height: 4px;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.9) 0%,
          transparent 70%
        );
        border-radius: 50%;
        pointer-events: none;
        animation: glimmer-fade 3s ease-out forwards;
        z-index: 12;
      }

      @keyframes glimmer-fade {
        0% {
          opacity: 0;
          transform: scale(0);
        }
        50% {
          opacity: 1;
          transform: scale(1);
        }
        100% {
          opacity: 0;
          transform: scale(1.5);
        }
      }
    </style>
  </head>
  <body>
    <canvas id="presence-canvas"></canvas>

    <div class="content">
      <h1>Orbweaver Natural Landcare</h1>
      <p>
        There's a different way to think about your outdoor space. One where you
        work with nature instead of declaring war on it every Sunday.
      </p>
      <p>
        We've been told land needs constant control. Trim this. Spray that.
        Fight back the chaos.
      </p>
      <p>
        But what if your garden already knows what it wants to become? What if
        the secret is just learning how to listen?
      </p>
      <p>Watch for the orbs... they appear when you're present.</p>
    </div>

    <script>
      const canvas = document.getElementById("presence-canvas");
      const ctx = canvas.getContext("2d");

      // Set canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Mouse position tracking
      let mouseX = window.innerWidth / 2;
      let mouseY = window.innerHeight / 2;
      let mouseStillTimer = 0;
      let lastMouseX = mouseX;
      let lastMouseY = mouseY;

      window.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        mouseStillTimer = 0;
      });

      // Orb class - living presences
      class Orb {
        constructor() {
          this.reset();
          // Start some orbs off-screen for gradual appearance
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
        }

        reset() {
          this.targetX = Math.random() * canvas.width;
          this.targetY = Math.random() * canvas.height;
          this.size = Math.random() * 15 + 5;
          this.baseOpacity = Math.random() * 0.3 + 0.1;
          this.opacity = 0;
          this.pulsePhase = Math.random() * Math.PI * 2;
          this.speed = Math.random() * 0.5 + 0.3;
          this.touchDistance = Math.random() * 100 + 50;
          this.hasApproached = false;
          this.approachCooldown = 0;
          this.glowIntensity = 0;
        }

        update() {
          // Fade in
          if (this.opacity < this.baseOpacity) {
            this.opacity += 0.001;
          }

          // Organic movement toward target
          const dx = this.targetX - this.x;
          const dy = this.targetY - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > 5) {
            this.x += (dx / distance) * this.speed;
            this.y += (dy / distance) * this.speed;
          } else {
            // Choose new target
            this.targetX = Math.random() * canvas.width;
            this.targetY = Math.random() * canvas.height;
          }

          // Gentle floating motion
          this.x += Math.sin(Date.now() * 0.0001 + this.pulsePhase) * 0.3;
          this.y += Math.cos(Date.now() * 0.0001 + this.pulsePhase) * 0.2;

          // Pulse
          this.pulsePhase += 0.01;

          // Check for mouse stillness and approach
          if (
            mouseStillTimer > 120 &&
            !this.hasApproached &&
            this.approachCooldown <= 0
          ) {
            const mouseDistance = Math.sqrt(
              Math.pow(this.x - mouseX, 2) + Math.pow(this.y - mouseY, 2)
            );

            if (mouseDistance < 200) {
              // Gently approach the still mouse
              this.targetX = mouseX + (Math.random() - 0.5) * 50;
              this.targetY = mouseY + (Math.random() - 0.5) * 50;
              this.speed = 0.8;
              this.glowIntensity = Math.min(1, this.glowIntensity + 0.02);

              if (mouseDistance < this.touchDistance) {
                this.hasApproached = true;
                this.approachCooldown = 300;
                // Create glimmer on "touch"
                createGlimmer(this.x, this.y);
              }
            }
          } else {
            this.speed = Math.random() * 0.5 + 0.3;
            this.glowIntensity = Math.max(0, this.glowIntensity - 0.01);
          }

          if (this.approachCooldown > 0) {
            this.approachCooldown--;
            if (this.approachCooldown === 0) {
              this.hasApproached = false;
            }
          }

          // Keep orbs in bounds with gentle redirect
          if (this.x < -50) this.targetX = canvas.width + 50;
          if (this.x > canvas.width + 50) this.targetX = -50;
          if (this.y < -50) this.targetY = canvas.height + 50;
          if (this.y > canvas.height + 50) this.targetY = -50;
        }

        draw() {
          const pulse = Math.sin(this.pulsePhase) * 0.2 + 1;
          const currentSize = this.size * pulse;

          // Outer glow
          const gradient = ctx.createRadialGradient(
            this.x,
            this.y,
            0,
            this.x,
            this.y,
            currentSize * 3
          );

          // Warmer, more subtle colors
          gradient.addColorStop(
            0,
            `rgba(255, 248, 220, ${
              this.opacity * 0.8 + this.glowIntensity * 0.3
            })`
          );
          gradient.addColorStop(
            0.3,
            `rgba(255, 236, 179, ${this.opacity * 0.4})`
          );
          gradient.addColorStop(
            0.6,
            `rgba(255, 218, 185, ${this.opacity * 0.2})`
          );
          gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, currentSize * 3, 0, Math.PI * 2);
          ctx.fill();

          // Inner light
          ctx.fillStyle = `rgba(255, 255, 240, ${
            this.opacity * 0.6 + this.glowIntensity * 0.4
          })`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, currentSize * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Create orbs
      const orbs = [];
      const orbCount = 7; // Sacred number, not too many
      for (let i = 0; i < orbCount; i++) {
        setTimeout(() => {
          orbs.push(new Orb());
        }, i * 2000); // Stagger their appearance
      }

      // Butterfly creation
      function createButterfly() {
        const butterfly = document.createElement("div");
        butterfly.className = "butterfly";
        butterfly.innerHTML = `
				<div class="butterfly-wing left"></div>
				<div class="butterfly-wing right"></div>
			`;
        document.body.appendChild(butterfly);

        const startX = Math.random() < 0.5 ? -50 : window.innerWidth + 50;
        let x = startX;
        let y = Math.random() * window.innerHeight;
        let vx = startX < 0 ? 1 : -1;
        let vy = (Math.random() - 0.5) * 0.5;
        let wavePhase = Math.random() * Math.PI * 2;

        butterfly.style.left = x + "px";
        butterfly.style.top = y + "px";

        setTimeout(() => {
          butterfly.style.opacity = "0.7";
        }, 100);

        const moveButterfly = () => {
          x += vx * 2;
          y += vy * 2 + Math.sin(wavePhase) * 1.5;
          wavePhase += 0.05;

          // Occasional direction change
          if (Math.random() < 0.02) {
            vy = (Math.random() - 0.5) * 0.5;
          }

          butterfly.style.left = x + "px";
          butterfly.style.top = y + "px";

          if (x < -60 || x > window.innerWidth + 60) {
            butterfly.style.opacity = "0";
            setTimeout(() => {
              document.body.removeChild(butterfly);
            }, 2000);
          } else {
            requestAnimationFrame(moveButterfly);
          }
        };

        requestAnimationFrame(moveButterfly);
      }

      // Create glimmer effect
      function createGlimmer(x, y) {
        const glimmer = document.createElement("div");
        glimmer.className = "glimmer";
        glimmer.style.left = x + "px";
        glimmer.style.top = y + "px";
        document.body.appendChild(glimmer);

        setTimeout(() => {
          document.body.removeChild(glimmer);
        }, 3000);
      }

      // Occasionally spawn butterflies
      setInterval(() => {
        if (Math.random() < 0.3) {
          // 30% chance every interval
          createButterfly();
        }
      }, 15000); // Check every 15 seconds

      // Animation loop
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update mouse stillness
        if (
          Math.abs(mouseX - lastMouseX) < 2 &&
          Math.abs(mouseY - lastMouseY) < 2
        ) {
          mouseStillTimer++;
        } else {
          mouseStillTimer = 0;
        }
        lastMouseX = mouseX;
        lastMouseY = mouseY;

        // Update and draw orbs
        orbs.forEach((orb) => {
          orb.update();
          orb.draw();
        });

        requestAnimationFrame(animate);
      }

      animate();

      // Initial butterfly after a moment
      setTimeout(createButterfly, 5000);
    </script>
  </body>
</html>
